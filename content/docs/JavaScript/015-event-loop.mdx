---
title: 说说你对事件循环的理解？
---

JavaScript 的 **事件循环（Event Loop）** 是其执行异步任务的核心机制，确保了 JavaScript 虽然是单线程语言，却能处理异步操作如定时器、网络请求、DOM 事件等而不会阻塞主线程。

---

### 🌱 一句话理解：

**事件循环是 JavaScript 用来处理同步任务和异步任务的机制。**

---

### 🧠 基本概念

#### 1. 单线程

JavaScript 是单线程语言（运行在主线程上），意味着同一时间只能做一件事。

#### 2. 执行栈（Call Stack）

* 存储当前正在执行的函数。
* 函数调用时入栈，执行完出栈。
* **所有同步任务在执行栈中按顺序执行。**

#### 3. Web APIs / 宏任务 / 微任务

* 异步操作（如 `setTimeout`, `DOM事件`, `fetch`）由浏览器的 Web API 环境先处理。
* 执行完毕后将回调函数加入任务队列。
* 任务队列分为**宏任务队列**和**微任务队列**。先处理微任务队列使其清空，再处理宏任务队列。

---

### 📦 任务类型

| 类型              | 说明                                                         | 举例                                                   |
| --------------- | ---------------------------------------------------------- | ---------------------------------------------------- |
| 宏任务（Macro Task） | 整个代码脚本、`setTimeout`、`setInterval`、`I/O`、`MessageChannel` 等 | `setTimeout(fn, 0)`                                  |
| 微任务（Micro Task） | 在当前宏任务执行完之后立即执行                                            | `Promise.then`, `queueMicrotask`, `MutationObserver` |

---

### 🌀 事件循环流程图解

```
主线程执行 ↓
执行栈为空 ↓
检查微任务队列 → 全部执行完 ↓
检查宏任务队列 → 取一个宏任务放入执行栈 ↓
回到第一步
```

---

### 🔁 举个例子

```js
console.log('start');

setTimeout(() => {
  console.log('timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise');
});

console.log('end');
```

#### 输出：

```
start
end
promise
timeout
```

#### 解释：

1. `'start'` 和 `'end'` 是同步任务，立即执行。
2. `Promise.then(...)` 是微任务，在当前宏任务完成后执行。
3. `setTimeout` 是宏任务，排在微任务后执行。

---

### ✅ 应用场景理解

* 保证 UI 不被阻塞（异步渲染）
* 实现异步请求、定时器、事件监听机制
* 实现任务调度器、动画帧控制等复杂异步控制逻辑

---

### 🧩 总结

> JavaScript 的事件循环模型通过**执行栈 + 任务队列（宏任务+微任务）**，实现了异步任务的调度能力，使得 JS 虽然是单线程，但仍然能高效应对各种异步需求。

---

## 补充：微任务和宏任务

微任务（**Microtask**）和宏任务（**Macrotask**）的主要区别在于：

---

### 🧠 本质区别

| 方面       | 微任务（Microtask）                                       | 宏任务（Macrotask）                                                        |
| -------- | ---------------------------------------------------- | --------------------------------------------------------------------- |
| **调度时机** | 当前宏任务执行结束后，**立即执行所有微任务**                             | 每次事件循环从宏任务队列中**取一个执行**                                                |
| **队列位置** | 微任务队列在宏任务之后执行                                        | 宏任务放在事件循环的队列中，**执行完微任务后才取下一个宏任务**                                     |
| **典型例子** | `Promise.then`, `queueMicrotask`, `MutationObserver` | `setTimeout`, `setInterval`, `setImmediate`, `MessageChannel`, `UI事件` |
| **优先级**  | 高（**先执行**）                                           | 低（**后执行**）                                                            |

---

### 🔁 执行顺序示意

```js
console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise1');
}).then(() => {
  console.log('promise2');
});

console.log('script end');
```

#### 输出顺序：

```
script start
script end
promise1
promise2
setTimeout
```

#### 解释：

1. 同步代码 `script start` 和 `script end` 最先执行。
2. `Promise.then(...)` 是 **微任务**，立即加入微任务队列，在当前宏任务结束后执行。
3. `setTimeout` 是 **宏任务**，排在微任务之后执行。

---

### 📌 补充理解

#### ✅ 微任务的特点：

* 微任务执行是**连续的**，直到队列清空为止。
* 会导致\*\*“卡主线程”\*\*，如果一直递归添加微任务，可能导致宏任务无法执行。

#### ✅ 宏任务的特点：

* 每一轮事件循环只执行一个宏任务，然后清空微任务队列。
* 宏任务之间可以插入浏览器的**渲染操作**（Repaint/ Reflow）。

---

### 🧩 简单记忆口诀

> **一次事件循环流程** = 执行一个宏任务 → 清空所有微任务 → 渲染 → 下一轮循环
