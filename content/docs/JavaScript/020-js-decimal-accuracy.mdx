---
title: 说说 Javascript 数字精度丢失的问题，如何解决？
---

在 JavaScript 中，**数字精度丢失** 是由于其使用 **IEEE 754 双精度浮点数（64 位）** 来表示数字所导致的。这种表示方式在处理十进制小数时无法做到完全精确，特别是在涉及 **小数的加减乘除、非常大的整数** 时，容易出现精度误差。

---

## 一、常见的精度丢失例子：

```javascript
0.1 + 0.2 === 0.3 // false
0.1 + 0.2         // 0.30000000000000004

9999999999999999  // 实际输出：10000000000000000（精度丢失）
```

---

## 二、精度丢失的本质原因：

JavaScript 使用 IEEE 754 标准的双精度浮点数表示所有数字：

```
1 位符号位 + 11 位指数位 + 52 位尾数位
```

像 `0.1` 和 `0.2` 这样的十进制小数在二进制中是 **无限循环小数**，所以无法完全表示，只能取近似值。累积后就会导致误差。

---

## 三、常见的解决方式

### ✅ 1. `toFixed()`（仅适用于显示）

```javascript
let sum = 0.1 + 0.2;
sum.toFixed(2); // "0.30"
```

* \*\*注意：\*\*返回的是字符串，若参与计算需用 `parseFloat()` 转换。
* \*\*问题：\*\*仍然是"四舍五入"，不适用于精密计算。

---

### ✅ 2. `Math.round()` 进行手动取整处理

```javascript
Math.round((0.1 + 0.2) * 100) / 100; // 0.3
```

适用于保留特定位数的小数。

---

### ✅ 3. 使用整数来处理浮点问题

将小数转换为整数后再计算，最后再缩放回去：

```javascript
function add(a, b) {
  let factor = Math.pow(10, 10);
  return (Math.round(a * factor) + Math.round(b * factor)) / factor;
}

add(0.1, 0.2); // 0.3
```

---

### ✅ 4. 使用第三方库（推荐）

#### 🔹 [Decimal.js](https://mikemcl.github.io/decimal.js/)

```javascript
const Decimal = require('decimal.js');
let result = new Decimal(0.1).plus(0.2);
console.log(result.toString()); // "0.3"
```

#### 🔹 Big.js / bignumber.js 也常用于金融场景，适合精准计算。

---

### ✅ 5. ES2020 `BigInt`（适用于大整数，不支持小数）

```javascript
const big = 9007199254740991n + 1n;
console.log(big); // 9007199254740992n
```

* 不能与普通数字混用。
* 不适合小数场景。

---

## 四、总结对比

| 方法               | 是否推荐   | 说明            |
| ---------------- | ------ | ------------- |
| toFixed()        | ✅（仅显示） | 适合 UI 展示      |
| Math.round 手动处理  | ✅      | 简单计算可用        |
| 转整数后计算           | ✅✅✅    | 通用、安全         |
| 第三方库（decimal.js） | ✅✅✅    | 推荐用于金融等精度敏感场景 |
| BigInt           | ⚠️     | 仅用于大整数，不支持浮点  |

