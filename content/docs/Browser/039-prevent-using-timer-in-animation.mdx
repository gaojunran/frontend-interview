---
title: 为什么不能使用计时器做 JS 动画？
---

这是一个很经典的问题 👍。表面上看，用 `setInterval` / `setTimeout` 定时更新元素样式就能做动画，但实际上 **计时器驱动的动画存在很多局限**，所以现代 Web 动画更推荐用 `requestAnimationFrame` (rAF) 或 CSS 动画。下面我详细解释一下为什么 **计时器不适合做 JS 动画**：

---

## 1. 计时器并不精确

* `setTimeout(fn, 16)` 你可能以为就是 **每 16ms 调用一次**，约等于 60fps。
* 但浏览器的 **事件循环 (event loop)** 会导致回调并不准时执行：

  * 如果主线程很忙（渲染、布局、JS 运算），回调就会被推迟。
  * 不同浏览器、不同硬件、后台 tab、CPU 降频，都会影响定时器精度。
* 结果：动画帧间隔不均匀，出现 **抖动 (jank)**。

---

## 2. 计时器与屏幕刷新不同步

* 显示器一般以 **固定刷新率** 渲染（常见 60Hz → 每 16.67ms 一帧）。
* `setInterval(..., 16)` 并不会和刷新时刻对齐，它可能在两次刷新中间触发。
* 结果：

  * 浏览器只能等到下次刷新时再把绘制结果推到屏幕。
  * 有些帧被丢弃，产生 **卡顿和撕裂感**。

---

## 3. 后台标签页和节能模式的问题

* 在后台 tab 或移动端省电模式下：

  * `setInterval`/`setTimeout` 会被浏览器 **强行降频**，甚至延迟到 1000ms。
  * 动画完全失真或跳帧。
* 而 `requestAnimationFrame` 会在后台自动暂停，恢复前台时再继续，非常节能。

---

## 4. `requestAnimationFrame` 的优势

现代浏览器推荐用 rAF，主要有三大好处：

1. **和屏幕刷新同步**：浏览器在准备渲染前调用 rAF，保证动画在最佳时机绘制。
2. **更流畅**：能最大化利用刷新率（60Hz、120Hz 显示器都适配）。
3. **节能**：后台自动停用，不浪费资源。

---

## 5. 举个对比例子

```js
// ❌ 用计时器实现动画
function animateTimer(el) {
  let pos = 0;
  let timer = setInterval(() => {
    pos += 2;
    el.style.transform = `translateX(${pos}px)`;
    if (pos > 300) clearInterval(timer);
  }, 16);
}

// ✅ 用 requestAnimationFrame 实现动画
function animateRAF(el) {
  let pos = 0;
  function step() {
    pos += 2;
    el.style.transform = `translateX(${pos}px)`;
    if (pos <= 300) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}
```

* **计时器版本**：在低性能机器、后台 tab 下容易掉帧、卡顿。
* **rAF 版本**：保证与屏幕刷新同步，流畅而稳定。

---

✅ 总结一句话：
**JS 动画不能用计时器的根本原因是它无法与浏览器渲染管线同步，时间精度也不可靠，会导致动画不流畅和能耗高。推荐用 `requestAnimationFrame` 或者 CSS 动画。**


