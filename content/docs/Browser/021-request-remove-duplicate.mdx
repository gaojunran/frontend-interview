---
title: 	同一前端页面的 3 个组件请求同一个 API 并发送了 3 次请求，如何优化？
---

同一个前端页面的多个组件同时请求同一个 API，导致发送了多次相同请求，这种情况很常见且可能造成不必要的网络开销和性能问题。优化思路主要是**避免重复请求**，实现请求共享或缓存。常见方案包括：

---

### 1. 请求去重（Request Deduplication）

* **思路**：当请求发出后，后续相同的请求不再重新发送，而是复用之前请求的 Promise，等接口响应回来后，所有请求共享结果。
* **实现方式**：

  * 使用一个全局请求缓存对象，key 用请求的 URL + 参数生成。
  * 发送请求前检查缓存，若存在则返回缓存的 Promise。
  * 请求完成后清理缓存或者根据策略缓存结果。

示例（伪代码）：

```js
const requestCache = new Map();

function fetchWithDedup(url) {
  if (requestCache.has(url)) {
    return requestCache.get(url);
  }
  const promise = fetch(url).then(res => res.json()).finally(() => {
    requestCache.delete(url);
  });
  requestCache.set(url, promise);
  return promise;
}
```

---

### 2. 全局状态管理（如 Redux / Vuex / Zustand 等）

* **思路**：由全局状态管理统一管理接口数据，多个组件订阅同一数据状态。
* 首个组件发起请求并存储数据，后续组件直接从状态管理中读取，无需重复请求。
* 优点是方便管理和维护数据，也支持数据共享和更新。

---

### 3. 使用 SWR、React Query、Vue Query 等数据缓存库

* 这些库内置了请求去重、缓存、自动刷新等功能。
* 组件请求相同接口时，库会自动共享请求结果，避免重复请求。

补充：[Pinia Colada]()

---

### 4. 组件间通信共享请求结果

* 父组件发起请求，将数据通过 props 传递给子组件，或者通过事件总线等方式共享请求结果，避免各组件各自请求。

---

### 5. 缓存策略

* 对接口结果做缓存，比如内存缓存、localStorage 缓存，根据业务需求设置过期时间，避免短时间内重复请求。

---

### 6. 结合防抖、节流

* 如果请求由用户交互触发，可以结合防抖、节流，减少请求频率。

---

**总结**：

最简单直接的做法是**请求去重**，即多个组件请求相同接口时，直接共享同一个请求的 Promise；更复杂的场景建议使用状态管理或者数据缓存库来集中管理接口数据。你想要我帮你写一个具体的代码示例吗？还是说你用的是 React、Vue 还是其他框架？
