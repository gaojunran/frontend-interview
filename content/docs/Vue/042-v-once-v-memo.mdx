---
title: v-once 和 v-memo 分别起什么作用？详细讲讲
---

在 Vue 中，`v-once` 和 `v-memo` 都是**渲染性能优化指令**，但它们的应用场景、行为机制和灵活度不同。下面详细讲讲它们的作用、区别和使用时机：

---

## 一、`v-once`

### ✅ 作用：

`v-once` 是一个**指令**，表示这个节点只渲染一次，之后无论依赖的数据是否发生变化，都不会重新渲染。

### 📌 特点：

* 静态内容的性能优化
* 一次性渲染，**跳过后续虚拟 DOM diff 过程**

### 🔧 使用示例：

```vue
<h1 v-once>{{ title }}</h1>
```

即使 `title` 后来被更新，这个 `<h1>` 也不会重新渲染。

### 🧠 内部原理：

* Vue 会在创建 vnode 时设置 `patchFlag: HOISTED`，把整个节点当作**静态内容**处理，不再参与 patch 对比。
* 节省 patch 过程的开销。

### ⚠️ 注意事项：

* 节点内容不会更新，**只适合用于永远不会改变的数据展示**。
* 如果加在父组件上，会影响子组件的响应式更新。

---

## 二、`v-memo`

> `v-memo` 是从 **Vue 3.2+ 引入的实验性功能**，用来更灵活地控制**缓存渲染结果**。

### ✅ 作用：

`v-memo` 允许你根据某些依赖值是否改变，决定是否要重新渲染这个组件/节点。

### 📌 特点：

* 更灵活的性能优化
* 允许你手动控制「要不要重新渲染」
* 类似 React 的 `memo()` 机制

### 🔧 使用示例：

```vue
<!-- 只有 count 变化时，才重新渲染 -->
<div v-memo="[count]">
  <p>{{ count }}</p>
  <p>{{ otherData }}</p>
</div>
```

如果 `otherData` 变化而 `count` 没变，`<div>` 会跳过渲染。

### 🧠 内部原理：

* Vue 会缓存当前虚拟 DOM 树，当 `v-memo` 的依赖数组中值没变时，直接使用缓存，不触发 diff 和更新。
* 渲染性能优化，但对内存有一定占用。

### ⚠️ 注意事项：

* 仍处于实验阶段，可能在未来版本中变动。
* 如果依赖项写得不准确，可能导致视图不同步。

---

## 三、对比总结

| 特性    | `v-once`          | `v-memo`               |
| ----- | ----------------- | ---------------------- |
| 功能    | 只渲染一次             | 根据依赖变化决定是否更新           |
| 是否响应式 | 否（彻底放弃更新）         | 是（受依赖项控制）              |
| 使用场景  | 静态内容、标语、logo 等    | 高性能组件、列表项、部分大 DOM 更新优化 |
| 灵活性   | 一刀切（一次性）          | 灵活配置更新条件               |
| Vue版本 | Vue 2 / Vue 3 均支持 | Vue 3.2+ 才支持，仍为实验性功能   |

---

## 四、什么时候用哪个？

* ✅ 使用 `v-once`：

  * 内容只展示一次，例如：版本号、版权信息、静态标语；
  * 不依赖响应式数据或数据不会变。

* ✅ 使用 `v-memo`：

  * 内容中包含响应式数据，但只希望根据**某些关键字段**变化时才重新渲染；
  * 用于复杂组件、列表项、性能瓶颈位置做细粒度控制。

---

如果你希望我对 `v-memo` 的底层机制或一个实际使用场景做深入展开，也可以继续问我。
