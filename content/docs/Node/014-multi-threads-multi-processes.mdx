---
title: 如何在 Node.js 中处理多线程或多进程操作？
---

在 Node.js 中，虽然主线程是单线程的（基于事件循环），但它提供了多种方式来进行多线程或多进程处理，以充分利用多核 CPU、提高并发性能。以下是详细的讲解：

---

## 🧠 背景：Node.js 单线程模型

* Node.js 的 JavaScript 执行是**单线程的**（基于 V8 引擎和事件循环）。
* 但它的底层 I/O 操作（如文件、网络）是**异步非阻塞**的，靠的是 libuv 提供的线程池。
* 要真正利用多核 CPU，Node.js 提供了以下几种方式实现并行处理。

---

## 🧵 方法一：Worker Threads（多线程）

> 从 Node.js v10.5 开始支持，适用于 CPU 密集型任务（如图像处理、加密等）。

### ✅ 特点：

* 真正的多线程（每个 Worker 是一个独立线程）
* 与主线程共享内存（使用 `SharedArrayBuffer`）
* 适合 CPU 密集型工作（不会阻塞事件循环）

### 🔧 示例：

```js
// main.js
const { Worker } = require('worker_threads');

function runWorker(workerData) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./worker.js', { workerData });

    worker.on('message', resolve);
    worker.on('error', reject);
    worker.on('exit', code => {
      if (code !== 0)
        reject(new Error(`Worker stopped with exit code ${code}`));
    });
  });
}

runWorker({ num: 42 })
  .then(result => console.log('Result:', result))
  .catch(err => console.error(err));
```

```js
// worker.js
const { parentPort, workerData } = require('worker_threads');

// 模拟 CPU 密集计算
let result = workerData.num * 2;
parentPort.postMessage(result);
```

---

## 🧩 方法二：Child Process（多进程）

> 启动一个新的 Node.js 进程，与主进程通过 IPC 通信。

### ✅ 特点：

* 每个子进程是独立的 Node 实例
* 通信靠 IPC（进程间通信）管道
* 适合执行外部命令、shell 脚本或隔离任务

### 🔧 示例：

```js
// main.js
const { fork } = require('child_process');

const child = fork('child.js');

child.send({ msg: 'start', value: 10 });

child.on('message', (data) => {
  console.log('Received from child:', data);
});
```

```js
// child.js
process.on('message', (data) => {
  console.log('Child received:', data);
  process.send({ result: data.value * 2 });
});
```

---

## 🧱 方法三：Cluster 模块（多进程 + 负载均衡）

> 用于创建多个 Node.js 实例监听同一个端口，实现负载均衡。

### ✅ 特点：

* 内部使用 child\_process.fork 创建子进程
* 适合构建 HTTP 服务的多核扩展

### 🔧 示例：

```js
// cluster_app.js
const cluster = require('cluster');
const http = require('http');
const os = require('os');

const numCPUs = os.cpus().length;

if (cluster.isPrimary) {
  // 主进程：分叉 worker
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
  });
} else {
  // 子进程：启动服务器
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Handled by worker ${process.pid}`);
  }).listen(8000);

  console.log(`Worker ${process.pid} started`);
}
```

---

## 🔁 对比总结

| 方法               | 并行模型 | 适用场景          | 通信方式        | 特点         |
| ---------------- | ---- | ------------- | ----------- | ---------- |
| `Worker Threads` | 多线程  | CPU 密集型任务     | 共享内存 / 消息   | 更轻量，线程间通信快 |
| `Child Process`  | 多进程  | 隔离任务、执行命令     | IPC / stdio | 更独立，启动开销大  |
| `Cluster`        | 多进程  | 多核扩展 HTTP 服务等 | 内置负载均衡      | 简单高效扩展服务器  |

---

## 🛠 推荐场景

* ✅ **CPU 密集型计算**：使用 `Worker Threads`
* ✅ **多核 HTTP 服务**：使用 `Cluster`
* ✅ **执行外部脚本、命令**：使用 `Child Process`
* ✅ **共享内存优化性能**：结合 `Worker Threads` 和 `SharedArrayBuffer`

---

如需进一步讲解某种方式的高级用法，或结合实际项目做例子，也可以告诉我！
