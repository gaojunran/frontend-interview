---
title: Koa 在处理请求时是如何利用事件循环的？
---

Koa 在处理请求时，本质上就是在 **Node.js 的事件循环 (event loop)** 机制之上，做了一层 **中间件控制流管理**。我分几个层次详细解释一下：

---

## 1. Node.js 的事件循环与 HTTP 请求

* Node.js 是单线程的，它的核心是事件循环。
* 当有新的 HTTP 请求到来时，`http` 模块会触发回调，把这个请求交给 Koa 的 `app.callback()`。
* 事件循环负责调度：

  * **网络 I/O（请求、数据库查询、文件读写等）** 会注册到 libuv 的事件队列。
  * 一旦结果就绪，回调会被放到 **宏任务队列**，由事件循环调度执行。
  * Promise 的 `.then` / `await` 会在 **微任务队列** 中优先执行。

因此，Koa 并不是自己管理“多线程”，它只是利用 Node 的事件循环，在 I/O 等待时把 CPU 还给事件循环，从而去处理其他请求。

---

## 2. Koa 的中间件执行模型（洋葱模型）

Koa 的核心就是 `koa-compose`，它把中间件组合成一个链式函数，类似：

```js
async function composed(ctx) {
  let index = -1
  async function dispatch(i) {
    if (i <= index) throw new Error('next() called multiple times')
    index = i
    let fn = middlewares[i]
    if (fn) {
      return await fn(ctx, () => dispatch(i + 1))
    }
  }
  return dispatch(0)
}
```

* 每个中间件接受 `(ctx, next)` 参数。
* `await next()` 表示：**把控制权交给下一个中间件**，并在它完成后恢复执行。
* 这就形成了“洋葱圈”式的执行顺序：

  * 请求先进入最外层中间件
  * 一层层深入
  * 等下层 `await` 完成后，再一层层返回

---

## 3. 事件循环在中间件中的角色

* 在中间件里，如果你 `await` 了一个异步操作（比如 `await fs.promises.readFile()`），事件循环会暂停当前中间件的执行，把线程让出去。
* Node 会继续处理其他请求的回调（即进入事件循环下一轮）。
* 当 I/O 完成时，对应的 Promise 被 resolve，回调进入 **微任务队列**，事件循环调度它继续运行，恢复到之前的 `await` 语句之后。

所以，**Koa 的请求处理过程并不会阻塞事件循环**，只要中间件写成异步的，CPU 就能在等待期间服务别的请求。

---

## 4. 整体请求生命周期（结合事件循环）

1. 客户端发起请求，Node `http` 模块把请求交给 `app.callback()`。
2. Koa 创建上下文对象 `ctx`。
3. `koa-compose` 执行中间件链，返回一个 Promise。
4. 如果中间件里有 `await`，当前请求会“挂起”，事件循环可以去执行别的请求或任务。
5. 异步操作完成，Promise resolve，事件循环把控制权交回中间件。
6. 所有中间件执行完后，Koa 处理响应并结束请求。

---

## 5. 关键点总结

* **事件循环负责调度所有请求与异步任务**。
* **Koa 本身不实现并发**，只是利用 async/await + Promise 把控制流挂到事件循环。
* **中间件像洋葱一样嵌套**，`await next()` 会把执行权交出去，等下层完成再回来。
* 如果有 **CPU 密集型任务**（比如循环计算），会阻塞事件循环，导致 Koa 无法处理其他请求 —— 这时要用 **worker\_threads 或子进程**。


