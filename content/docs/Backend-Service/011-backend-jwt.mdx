---
title: 详细讲讲后端实现 JWT 的流程？
---

下面给你**完整、可操作**的后端实现 JWT（JSON Web Token）流程说明 —— 从原理到实战、陷阱与最佳实践，带上关键代码片段（Node.js）和常见防护手段。按步骤走，方便在真实项目里落地。

# 1. JWT 是什么（快速回顾）

* JWT 由三段组成：`header.payload.signature`，均为 **Base64URL** 编码后以点号连接。

  * header（例如 `{"alg":"HS256","typ":"JWT"}`）定义签名算法等。
  * payload（Claims）包含标准声明（`iss, sub, aud, exp, iat, nbf, jti`）和自定义声明（例如 `role`）。
  * signature = `SIGN(Base64URL(header) + "." + Base64URL(payload), secret_or_private_key)`
* 常见算法：对称 `HS256`（HMAC + secret），非对称 `RS256`（RSA 私钥签名，公钥验证）。
* 特点：默认**无状态**（服务器不保存 access token），验证只需公/私钥或 secret。

# 2. 后端实现的总体流程（端到端）

1. 用户提交凭证（用户名/密码、OAuth code 等）到后端 `/login`。
2. 后端验证凭证（查库、校验密码哈希）。
3. 验证通过后：生成 **Access Token（短期 JWT）**，可选生成 **Refresh Token（长期、建议为不透明随机串）**。
4. 将 Access Token 返回给客户端（通常放在 Authorization header 的 `Bearer`，或 HttpOnly cookie）。
5. 客户端在之后的 API 请求中携带 Access Token -> 后端在中间件里 **验证签名/声明/过期** -> 放行或拒绝。
6. Access Token 过期后，客户端用 Refresh Token 到 `/refresh` 端点换取新的 Access Token（可能同时轮换 refresh token）。
7. 登出或安全事件时，后端撤销 refresh token（或增加 token 版本号使旧 token 无效）。

# 3. 关键实现细节与注意点

## 3.1 生成 token（示例，Node.js）

```js
// npm i jsonwebtoken
const jwt = require('jsonwebtoken');

const ACCESS_SECRET = process.env.ACCESS_SECRET;   // HS256 的 secret，或 RS256 的私钥
const ACCESS_EXPIRES_IN = '15m';

function signAccessToken(user) {
  const payload = {
    sub: user.id,
    role: user.role,
    // 可加入 tokenVersion、tenantId 等
  };
  const opts = { issuer: 'my-app', audience: 'my-api', expiresIn: ACCESS_EXPIRES_IN };
  return jwt.sign(payload, ACCESS_SECRET, opts); // 若 RS256：第二个参数是私钥，opts.algorithm = 'RS256'
}
```

## 3.2 验证 token（中间件）

```js
function authenticate(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth?.startsWith('Bearer ')) return res.status(401).send('no token');
  const token = auth.split(' ')[1];
  jwt.verify(token, ACCESS_SECRET, { issuer: 'my-app', audience: 'my-api' }, (err, payload) => {
    if (err) return res.status(401).send(err.message);
    // optional: 检查 payload.jti 是否在黑名单，或 payload.tokenVersion 与用户 DB 对比
    req.user = payload;
    next();
  });
}
```

## 3.3 Refresh Token：opaque vs JWT

* **建议**把 Refresh Token 做成 **不透明随机串**（`crypto.randomBytes(64).toString('hex')`），并把它与用户 ID、过期时间、设备信息一起存到数据库。理由：便于撤销、轮换和检测盗用。
* 也可以用 JWT 来做 refresh token，但那样撤销困难（除非存黑名单或 tokenVersion）。

## 3.4 Refresh 流程（安全实现要点）

1. `/refresh` 从 HttpOnly cookie（或 Authorization）读取 refresh token。
2. 在数据库查找 refresh token，验证是否存在、未过期、未撤销，且对应用户未被禁用。
3. 若合法：生成新的 access token，并**轮换** refresh token（生成新随机串，替换 DB 中的旧值，返回新串并设置 HttpOnly cookie）。
4. 若发现 refresh token 异常（重复使用/盗用），则：

   * 立即撤销该用户所有 refresh token（强制登出），并触发安全告警。

## 3.5 撤销策略（因为 JWT 天生无状态）

* **短过期 + refresh token**：access token 很短（例如 5–15 分钟），refresh token 承担续期。
* **tokenVersion**：在用户表中保存 `tokenVersion`，把它写入 JWT 的 payload；强制使该用户失效时把 `tokenVersion++`。服务只需比对 DB 中的版本号即可使旧 JWT 失效（适合少量用户）。
* **黑名单（Redis）**：在关键场景将被撤销的 `jti` 存入 Redis，Jwt 验证时查 Redis。适合少量撤销条目。
* **刷新策略**：使用一次性 refresh token（rotate on use）+ 列出失效 token 检测重放。

# 4. 安全、存储与传输注意事项

* **不要把敏感长期 token 放 localStorage**（易被 XSS 窃取）。最安全的做法：把 refresh token 放 `HttpOnly`, `Secure`, `SameSite` cookie；access token 可以短期放内存并随 Authorization header 发送。
* 如果把 JWT 放 cookie，注意 CSRF：使用 `SameSite=Lax/Strict` 或为敏感写操作加 CSRF token（双重提交 cookie）。
* 校验 JWT 的 **iss, aud, exp, nbf, iat**。不要只依赖 signature。
* 不要把过多敏感信息写进 payload（payload 可被解码）。
* 采用 **非对称签名（RS256）** 当你需要第三方或多个服务共享验证公钥时；对称（HS256）简单但 secret 必须在所有验证端共享并妥善保护。
* 支持 **key rotation**：在 header 中使用 `kid` 指示 key id；服务器维护 kid->key 的映射，便于平滑切换公/私钥。
* 在登录/刷新失败多次后，需要封号或强制用户重新认证以防暴力攻击。

# 5. 常见扩展设计（实践中会用到）

* **Scope / roles**：在 payload 中带 `scope` 或 `roles`，细粒度授权由后端根据这些声明实现。
* **多设备支持**：把 refresh token 与设备 id 绑定；用户可在 UI 管理已登录设备并撤销某些设备的 refresh token。
* **审计（jti）**：给每个 token 设置 `jti`（唯一 id），用于日志、审计、撤销。
* **Token 最小化**：若需要频繁检查用户状态（例如注销/变更权限），可把 access token 设计为只包含少许信息，后端再查询用户状态表。

# 6. 完整示例：登录 → 访问受保护接口 → 刷新（Node.js 伪代码）

```js
// 伪 DB：users, refresh_tokens
// 1. /login
POST /login {username, password}:
  user = findUser(username)
  if (!user || !verifyPwd(password, user.hash)) return 401
  access = signAccessToken(user) // 短期 JWT
  refresh = randomToken()
  storeRefreshToken({ token: refresh, userId: user.id, expiresAt: now+30d })
  setCookie('refreshToken', refresh, { httpOnly:true, secure:true, sameSite:'lax' })
  return { access } // 或者把 access 也放 cookie

// 2. 受保护接口 (middleware authenticate)
Authorization: Bearer <access>
authenticate -> jwt.verify -> req.user = payload -> next

// 3. /refresh
POST /refresh:
  refresh = readCookie('refreshToken')
  row = findRefreshToken(refresh)
  if (!row || row.isRevoked || row.expiresAt < now) return 401
  // rotate
  newRefresh = randomToken()
  replaceRowToken(row.id, newRefresh, newExpiresAt)
  access = signAccessToken(user)
  setCookie('refreshToken', newRefresh, { httpOnly:true, secure:true })
  return { access }
```

# 7. 常见错误与坑

* 把长寿命的 JWT 放到 localStorage（XSS 风险）。
* 只验证签名不验证 `aud`/`iss`/`exp`。
* 用相同 secret 在多个服务间共享但没有 key rotation 方案。
* 误把 JWT 当作 session（期望随时能服务器端撤销），忘了设计撤销策略。
* refresh token 未做轮换或未在 DB 存储，导致无法撤销。

# 8. 最佳实践小结（快速清单）

* Access token 短期（5–15 分钟）；refresh token 安全存储并轮换。
* refresh token 用不透明随机串并存在服务器（便于撤销）。
* 在 payload 中包含 `sub, iss, aud, exp, iat, jti`，并在验证时检查这些字段。
* 对跨站点与 XSS 做防护：HttpOnly + SameSite cookie、内容安全策略、输入校验。
* 使用 RS256 + kid 支持复杂部署 & key rotation（如果需要跨服务/第三方验证）。
* 审计与监控：记录 refresh token 的 IP/UA，检测异常登录与重放。

---

如果你愿意，我可以：

* 基于你当前后端技术栈（例如 Node/Express、Koa、Flask、Spring Boot、Go）给出**可直接复制粘贴**的完整示例（含 DB schema、表结构与 Redis 例子），或者
* 帮你设计一个**refresh token 数据库表结构**和**登录/刷新/登出完整 API 设计**（含示意请求与响应格式）。

你想看哪一个？

