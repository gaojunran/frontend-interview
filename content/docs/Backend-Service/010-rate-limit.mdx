---
title: 接口速率限制的方法有哪些？
---

好的 👍 我来详细讲讲这两种常见的限流算法：

---

## 🔹 1. Token Bucket（令牌桶算法）

### **基本原理**

* 系统维护一个“桶”，桶里会以固定速率产生令牌（例如每 100ms 放 1 个）。
* 每个请求到达时，必须拿到一个令牌才能被处理。
* 如果桶里有令牌，请求就通过并消耗掉一个令牌；如果没有令牌，请求就被拒绝（或等待）。
* 桶有最大容量，满了就不会再增加新令牌，从而避免无限积压。

### **特点**

1. **平滑限流**：请求处理速率基本和令牌产生速率一致。
2. **允许突发流量**：如果桶里积攒了一些令牌，短时间内可以处理比平均速率更多的请求。
3. **实现简单**：常用于 API 网关、消息队列消费者等场景。

### **类比**

* 像高速公路收费站：

  * 收费站每秒发车票（令牌），车子（请求）必须有票才能进高速。
  * 如果司机手里攒了票，就能一次放很多车（突发流量）。
  * 没票的车只能等下次发票，或者直接被拦下。

---

## 🔹 2. 滑动时间窗口（Sliding Window）

### **基本原理**

* 给定一个时间窗口大小，比如 **1 秒**。
* 系统统计这 1 秒内的请求数，如果超过设定阈值（例如 100 次），就拒绝后续请求。
* **滑动**的意思是：窗口不是固定对齐的（比如 12:00:00\~12:00:01），而是随时间连续滑动，保证统计更精确。

### **实现方式**

1. **固定窗口（Fixed Window）**

   * 例如 1 秒一个格子：
     12:00:00\~12:00:01 → 最多 100 请求
     12:00:01\~12:00:02 → 最多 100 请求
   * 缺点：在边界时可能瞬间双倍流量（临界问题）。
     （比如 0.999 秒发 100 个请求，1.001 秒又发 100 个，请求间隔 2ms，但被允许 200 个。）

2. **滑动窗口（Sliding Window Counter）**

   * 把窗口切分成更小的格子（如 100ms 一个），每次统计最近 N 个格子里的总和。
   * 这样避免了固定窗口的临界突刺问题。

3. **滑动日志（Sliding Log）**

   * 记录每次请求的时间戳。
   * 新请求进来时，清理掉超出窗口的旧请求，然后判断数量是否超限。
   * 精度高，但内存开销大。

### **特点**

* 精确控制某时间段内的请求数。
* 更严格地限制流量，而不像令牌桶那样允许短时间突发。
* 常用于登录保护、短信验证码频控等“必须绝对严格”的场景。

---

## 🔹 两者对比

| 特性         | Token Bucket     | Sliding Window      |
| ---------- | ---------------- | ------------------- |
| **是否允许突发** | ✅ 允许（桶里积累令牌）     | ❌ 通常不允许（严格限制窗口内请求数） |
| **限流方式**   | 控制请求平均速率         | 控制窗口内总请求数           |
| **实现复杂度**  | 中等（要维护令牌生成）      | 从简单到复杂（计数器 / 日志）    |
| **适用场景**   | API 网关、消息消费、带宽控制 | 登录防刷、验证码、防止接口被频繁调用  |

---

🔑 总结：

* **令牌桶**：强调 **速率**，适合平滑处理流量并容忍一定突发。
* **滑动时间窗口**：强调 **数量**，适合严格限制请求总量。

---

要不要我给你写一段 **Node.js/Koa 示例代码**，分别用 **令牌桶** 和 **滑动时间窗口** 实现限流？
